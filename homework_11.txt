2#
2.4 GHz
1 	2.401  	2.412 	2.423
2 	2.406 	2.417 	2.428
3 	2.411  	2.422 	2.433
4 	2.416 	2.427 	2.438
5 	2.421 	2.432 	2.443
6 	2.426 	2.437 	2.448
7 	2.431 	2.442 	2.453
8 	2.436 	2.447 	2.458
9 	2.441 	2.452 	2.463
10 	2.446 	2.457 	2.468
11 	2.451 	2.462 	2.473
12 	2.456 	2.467 	2.478
13 	2.461 	2.472 	2.483

Полоса частот 5 ГГц имеет более сложную структуру по сравнению с 2,4 ГГц. Она занимает полосу частот с 5150 до 5825 МГц. Однако каналы на этом промежутке распределены неравномерно они занимают три сплошных участка: UNII-1,2,3. Для WiFi 5GHz частоты каналов распределены следующим образом. На первой полосе расположены каналы 36, 40, 44, 80. На второй — 52, 56, 60, 64, 100, 104, … , 136, 140. Третья включает в себя 149, 153, 157, 161.

#3
Apple

#4
MSS = MTU - IPv4 - TCP
MSS = 9001 - (20 + 32)
MSS = 8049

#5
Установка флагов SYN и FIN позволяет пакету пройти через статический фильтр пакетов, так как такие фильтры блокируют только SYN-пакеты. Однако если такой пакет поступит на открытый порт Windows или UNIX-системы, то в ответ будет отправлен SYN/ACK-пакет.
Сочетание символов SYN и FIN, установленных в заголовке TCP, является незаконным и относится к категории нелегальных /ненормальных сочетаний флагов, поскольку оно требует как установления соединения (через SYN), так и завершения соединения (через FIN).
Метод обработки таких незаконных /ненормальных сочетаний флагов не передается в RFC TCP. Таким образом, такие незаконные /аномальные комбинации флагов обрабатываются по-разному в различных операционных системах. Различные операционные системы также генерируют разные ответы для таких пакетов.
Таким образом, такие комбинации флагов всегда рассматриваются как вредоносные, а современные системы обнаружения вторжений обнаруживают такие комбинации, чтобы избежать атак.

#6
В State присутствует только UNCONN т.к. утилита ss вызвана с флагом -u (display only UDP sockets), из-за чего TIME-WAIT быть не может (может быть только у TCP), но может быть ESTAB.

#7
. 	TCP A                                               	. 	TCP B
1. 	ESTABLISHED                                         	. 	ESTABLISHED
2. 	(Close)
FIN-WAIT-1 	--> 	<SEQ=100><ACK=300><CTL=FIN,ACK> 	--> 	CLOSE-WAIT
3. 	FIN-WAIT-2 	<-- 	<SEQ=300><ACK=101><CTL=ACK> 	<-- 	CLOSE-WAIT
4. 	(Close)
TIME-WAIT 	<-- 	<SEQ=300><ACK=101><CTL=FIN,ACK> 	<-- 	LAST-ACK
5. 	TIME-WAIT 	--> 	<SEQ=101><ACK=301><CTL=ACK> 	--> 	CLOSED
6. 	(2 MSL)
CLOSED
Когда клиент инициирует закрытие создается сегмент с сигналом FIN и помещается в очередь сегментов, ждущих отправления. После этого программа TCP уже не будет принимать от этого клиента каких-либо команд на отправление данных по закрытому соединению, а сама переходит в со стояние FIN-WAIT-1. Тем не менее, в этом состоянии еще возможно получение клиентом данных с этого соединения. Все сегменты, стоящие в очереди, и сам сегмент с сигналом FIN будут в случае необходимости посылаться напарнику вновь и вновь, пока не получат своего подтверждения. Когда программа TCP партнера подтвердит получение сигнала FIN, и сама отправит сюда свой сигнал FIN, местная программа может подтвердить получение последнего. Заметим, что программа TCP, получающая сигнал FIN, будет подтверждать его, но не будет посылать своего собственного сигнала FIN до тех пор, пока ее клиент тоже не закроет соединения. 

#8
Порты - это 16-разрядные номера, поэтому максимальное количество подключений, которое любой конкретный клиент может иметь к любому данному хост-порту, составляет 64 КБ (2^16). Тем не менее, у нескольких клиентов может быть до 64K подключений к некоторому серверному порту, и если у сервера есть несколько портов или он многопользовательский, то вы можете умножить это дальше. Таким образом, реальный предел является файловыми дескрипторами. Каждому отдельному сокетному соединению предоставляется файловый дескриптор, поэтому ограничение - это действительно количество дескрипторов файлов, которые система настроена для разрешения и ресурсов для обработки. Максимальный предел, как правило, превышает 300K.
С одного IP может подключиться до 64k клиентов, с другого ещё столько же и т.д. Таким образом, теоретическое максимальное число соединений может быть равно число клиентских IP адресов * число портов на клиенте (64k). С практической же точки зрения, ресурсы сервера (RAM, CPU, I/O) ограничены, и в зависимости от реализации сервера, он может обрабатывать лишь какое-то N-ное число одновременных соединений, которое меньше теоретического IP*64k.

#9
Такая ситуация может возникнуть, когда клиент активно подключается/отключается к удаленной службе. Поскольку оба IP и удаленный порт остаются неизменными, то на каждое новое соединение выделяется новый локальный порт. Если клиент был активной стороной завершения TCP-сессии, то это соединение будет заблокировано какое-то время в состоянии TIME_WAIT. Если соединения вoстанавливаются быстрее чем порты выходят из карантина, то при очередной попытке соединения клиент получит ошибку EADDRNOTAVAIL (errno=99).
Eсли приложения обращаются к разным службам и ошибки не роисходит, очередь TIME_WAIT будет расти, забирая системные ресурсы. 
При DDOS-атаке такое может происходить.

#10
Фрагментация данных UDP выполняется на уровне IP, когда размер данных превышает размер максимального блока передачи (MTU) локальной сети. В стеке TCP/IP эту задачу решает протокол TCP, который разбивает поток байтов, передаваемый ему с прикладного уровня на сообщения нужного размера, поэтому протокол IP в узле-отправителе не использует свои возможности по фрагментации пакетов. IP разбивает данные на блоки таким образом, чтобы размер исходящих пакетов не превышал ограничения MTU. Пакеты помещаются в очередь вывода устройства и передаются адаптером локальной сети системе-получателю, если очередь вывода устройства переполнена, пакет отбрасывается. Поступающие пакеты помещаются в очередь приема драйвера устройства и передаются уровню IP через интерфейсный уровень. Если уровень IP в принимающей системе определяет, что уровень IP в передающей системе разбил данные на фрагменты, он собирает фрагменты в исходный блок данных и передает его уровню TCP или UDP. TCP при необходимости объединяет сегменты данных и помещает данные в буфер приема сокета, UDP передает полученные данные в буфер приема сокета. Если буфер приема сокета (udp_recvspace) переполнен, то пакет отбрасывается.

#11
Я бы выбрал более надежное хоть и медленное TCP, но не угадал.
Syslog использует протокол User Datagram Protocol (UDP) для передачи информации о событиях непосредственно на центральный сервер syslog.
514 порт SYSLOG (сообщения системы)

#12
[q@asus ~]$ ss -lt
State   Recv-Q  Send-Q     Local Address:Port       Peer Address:Port  Process  
LISTEN  0       4096           127.0.0.1:19999           0.0.0.0:*              
LISTEN  0       4096           127.0.0.1:9040            0.0.0.0:*              
LISTEN  0       4096       127.0.0.53%lo:domain          0.0.0.0:*              
LISTEN  0       128              0.0.0.0:ssh             0.0.0.0:*              
LISTEN  0       5              127.0.0.1:ipp             0.0.0.0:*              
LISTEN  0       100              0.0.0.0:smtp            0.0.0.0:*              
LISTEN  0       4096           127.0.0.1:9050            0.0.0.0:*              
LISTEN  0       4096           127.0.0.1:8125            0.0.0.0:*              
LISTEN  0       128                 [::]:ssh                [::]:*              
LISTEN  0       5                  [::1]:ipp                [::]:*              
LISTEN  0       100                 [::]:smtp               [::]:* 

[q@asus ~]$ for port in `ss -lt |  awk '{print $4}' | sed '1d' | cut -d ":" -f2 | xargs`; do sudo lsof -ni :$port; done
COMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
netdata 1962 netdata    4u  IPv4  39032      0t0  TCP 127.0.0.1:19999 (LISTEN)
COMMAND PID       USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
tor     792 debian-tor    8u  IPv4  34808      0t0  TCP 127.0.0.1:9040 (LISTEN)
COMMAND   PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
systemd-r 580 systemd-resolve   12u  IPv4  20440      0t0  UDP 127.0.0.53:domain 
systemd-r 580 systemd-resolve   13u  IPv4  20441      0t0  TCP 127.0.0.53:domain (LISTEN)
tor       792      debian-tor    7u  IPv4  34807      0t0  UDP 127.0.0.1:domain 
COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    780 root    3u  IPv4  33866      0t0  TCP *:ssh (LISTEN)
sshd    780 root    4u  IPv6  33877      0t0  TCP *:ssh (LISTEN)
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
cupsd     721 root    6u  IPv6  31532      0t0  TCP [::1]:ipp (LISTEN)
cupsd     721 root    7u  IPv4  31533      0t0  TCP 127.0.0.1:ipp (LISTEN)
cups-brow 742 root    7u  IPv4  32495      0t0  UDP *:631 
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
master  1958 root   13u  IPv4  37868      0t0  TCP *:smtp (LISTEN)
master  1958 root   14u  IPv6  37869      0t0  TCP *:smtp (LISTEN)
COMMAND PID       USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
tor     792 debian-tor    6u  IPv4  34806      0t0  TCP 127.0.0.1:9050 (LISTEN)
COMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
netdata 1962 netdata   17u  IPv4  40013      0t0  UDP 127.0.0.1:8125 
netdata 1962 netdata   20u  IPv4  40014      0t0  TCP 127.0.0.1:8125 (LISTEN)

#13
Чтобы увидеть содержимое пакета, tcpdump предоставляет два дополнительных флага: -X для печати содержимого в шестнадцатеричном формате (HEX) и -A для печати содержимого в ASCII.

#14
[q@asus ~]$ sudo tcpdump -D
1.enp1s0 [Up, Running]
2.lo [Up, Running, Loopback]
3.any (Pseudo-device that captures on all interfaces) [Up, Running]
4.bluetooth-monitor (Bluetooth Linux Monitor) [none]
5.nflog (Linux netfilter log (NFLOG) interface) [none]
6.nfqueue (Linux netfilter queue (NFQUEUE) interface) [none]

[q@asus ~]$ sudo tcpdump -i enp1s0 -c 100 -w dump.pcap

Ethernet - стандарт IEEE 802.3 
sudo tshark -r dump.pcap -V | grep Flags
Флаг "Дополнительные Фрагменты"
Флаг "Дополнительные Фрагменты" (MF) является одиночным битом в поле Флагов, используемым со Смещением Фрагмента для фрагментации и реконструкции пакетов. Когда флаг "Дополнительные Фрагменты" устанавливается, это означает, что это не последний фрагмент пакета. Когда узел получения видит, что пакет прибывает с MF = 1, он исследует Смещение Фрагмента, чтобы определить, куда этот фрагмент должен быть помещен в рекоструируемом пакете. Когда узел получения принимает кадр с MF = 0 и ненулевое значение в смещении Фрагмента, он помещает этот фрагмент как последнюю часть в восстанавливаемый пакет. У нефрагментированного пакета вся информация о фрагментации равна нулю (MF = 0, смещение фрагмента = 0).
Флаг "Не Фрагментировать"
Флаг "Не Фрагментировать" (DF) является одиночным битом в поле Флагов, который указывает, что фрагментация пакета не допустима. Если бит флага "Не Фрагментировать" устанавливается, то фрагментация этого пакета НЕ разрешается. Если маршрутизатор должен фрагментировать пакет, чтобы передать его вниз к Канальному уровню, но бит DF установлен в 1, то маршрутизатор отбрасывает этот пакет.

Можно ли где-то в дампе увидеть OUI?
Усли вывести данные в формате [q@asus ~]$ tshark -r dump.pcap -T pdml , то OUI можно увидет в showname='...'
